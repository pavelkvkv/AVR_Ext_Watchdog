/**
 * @file main.c
 * @brief Компактная программа для ATtiny13A с подсчетом импульсов через Timer0.
 *
 * Измеряет число внешних импульсов на PB1 (внешний тактовый вход Timer0) за интервал MEASURE_PERIOD_MS.
 * Если итоговое число импульсов (учитывая переполнения 8-битного таймера) меньше MIN_PULSES или больше MAX_PULSES,
 * генерируется сброс внешнего устройства через PB0 (выход с "открытым коллектором").
 */

 #define F_CPU 9600000UL*2   // Рабочая частота 9.6 МГц

 #include <avr/io.h>
 #include <avr/interrupt.h>
 #include <util/delay.h>
 #include <avr/wdt.h>
 
 #define MEASURE_PERIOD_MS    200      ///< Интервал измерения импульсов (мс)
 #define POST_EVENT_DELAY_MS  200      ///< Задержка после сброса или старта (мс)
 #define RESET_PULSE_WIDTH_MS 50      ///< Длительность сбросного импульса (мс)
 #define MIN_FREQ           2000UL      ///< Минимальное число импульсов за sec
 #define MAX_FREQ           20000UL     ///< Максимальное число импульсов за sec
 #define MIN_PULSES         (MIN_FREQ*MEASURE_PERIOD_MS/1000)    ///< Минимальное число импульсов за интервал
 #define MAX_PULSES         (MAX_FREQ*MEASURE_PERIOD_MS/1000)    ///< Максимальное число импульсов за интервал
 
 volatile uint8_t pulse_high = 0;     // "Второй разряд" счетчика (количество переполнений Timer0)
 
 // Обработчик прерывания переполнения Timer0
 ISR(TIM0_OVF_vect)
 {
     pulse_high++; // Инкрементируем старший разряд счетчика
 }
 
 int main(void)
 {
     // Настраиваем пины:
     // PB1 - вход для внешнего тактового сигнала Timer0 (подключается непосредственно к внешнему импульсному генератору)
     // PB0 - выход для сброса (по умолчанию high-Z, используется как "открытый коллектор")
     DDRB &= ~(1 << PB1);  // PB1 как вход
     DDRB &= ~(1 << PB0);  // PB0 как вход

     OSCCAL = 127;
 
     // Настройка Timer0:
     // Режим нормальный, внешний тактовый сигнал (восходящий фронт) через TCCR0B = 0b00000111.
     // Это позволяет таймеру считать внешние импульсы, поступающие на PB1.
     TCCR0A = 0;
     TCCR0B = 0b00000111;
 
     // Разрешаем прерывание переполнения Timer0
     TIMSK0 |= (1 << TOIE0);
 
     wdt_enable(WDTO_1S);  // Включаем watchdog (~1 сек)
     sei();                // Глобально разрешаем прерывания
 
     while (1)
     {
         wdt_reset();                     // Сброс watchdog
         _delay_ms(POST_EVENT_DELAY_MS);  // Задержка после сброса или старта
 
         // Сброс счетчика: обнуляем "старший разряд" и сам Timer0
         pulse_high = 0;
         TCNT0 = 0;
 
         _delay_ms(MEASURE_PERIOD_MS);    // Измерительный интервал
 
         // Считываем общее число импульсов: (pulse_high << 8) | TCNT0
         cli();
         uint16_t pulses = ((uint16_t)pulse_high << 8) | TCNT0;
         sei();
 
         // Если число импульсов вне допустимого диапазона, инициируем сброс внешнего устройства
         if (pulses < MIN_PULSES || pulses > MAX_PULSES)
         {
             DDRB |= (1 << PB0);    // Переводим PB0 в режим выхода
             PORTB &= ~(1 << PB0);  // Выводим 0 (сброс)
             _delay_ms(RESET_PULSE_WIDTH_MS);
             DDRB &= ~(1 << PB0);   // Возвращаем PB0 в режим high-Z
             PORTB &= ~(1 << PB0);
         }
     }
     return 0;
 }
 